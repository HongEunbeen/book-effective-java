# Item 21 - 인터페이스는 구현하는 쪽을 생각해 설계하라

### 자바 8 이전

- 기존 구현체를 깨뜨리지 않고는 인터페이스에 메서드를 추가할 방법 없었다.
- 인터페이스는 바뀌면 안된다.

### 자바 8 디폴트 메서드

- 기존 인터페이스에 메서드 추가 가능
    - 인터페이스를 구현한 후 디폴트 메서드를 재 정의하지 않은 모든 클래스에서 디폴트 구현이 쓰이게 된다.
    - 컬렉션 인터페이스들에 다수의 디폴트 메서드가 추가되었다.
    - 예제1 → List 인터페이스에 추가된 sort() 메서드

        ```java
        default void sort(Comparator<? super E> c){
        	Object[] a = this.toArray();
        	Arrays.sort(a, (Comparator) c);
        	ListIterator<E> i = this.listInterator();
        	for(Oject e : a){
        		i.next();
        		i.set((E) e);
        	}
        }
        ```

    - 예제2

        ```java
        //Main.java
        interface MyInterface {
            default void printHello() {
                System.out.println("Hello World");
            }
        }

        class MyClass implements MyInterface {
        }

        public class Main {
            public static void main(String[] args) {
                MyClass myClass = new MyClass();
                myClass.printHello(); // 실행결과 Hello World 출력
            }
        }
        ```

- 주로 람다 활용 위해 추가, **코드 품질이 높고 범용적이라 대부분 상황에서 잘 작동**한다.
- **디폴트 메서드 단점**
    - 디폴트 메서드를 재정의 하지 않은 모든 클래스에서 디폴트 구현이 사용
    - 디폴트 메서드는 컴파일에 성공하더라도 기존 구현체에 런타임 오류를 일으킬 수 있다.
        - 예시 자바 8의 Collection 인터페이스에 추가된 removeIf 메서드
            - removeIf 메서드
                - 주어진 불리언 함수가 true를 반환하는 모든 원소를 제거한다.
                - 디폴트 구현 → 반복자를 이용해 순회하면서 각 원소를 인수로 넣어 프레디키트를 호출
                - 프레디키트가 true를 반환하면 반복자의 remove 메서드를 호출해 그 원소를 제거한다.

            → **현존하는 모든 Collection 구현체와 잘 어우러지는 것은 아니다.**

    - 모든 기존 구현체들과 매끄럽게 연동 보장 없음

      → 자바 7까지의 세상에서는 모든 클래스가 '**현재의 인터페이스에 새로운 메서드가 추가될 일은 영원히 없다**'고 가정되어 작성되었기 때문

      → 생각할 수 있는 모든 상황에서 불변식을 해치지 않는 디폴트 메서드를 작성하기랑 어려운 법

### 디폴트 메서드의 사용시 주의사항

- 기존 인터페이스에 디폴트 메서드로 **새 메서드 추가하는 일은 꼭 필요한 경우가 아니면 피해야 한다**.
    - 디폴트 메서드는 (컴파일에 성공하더라도) 기존 구현체에 런타임 오류를 일으킬 수 있다
- 디폴트 메서드라는 도구가 생겼더라도 **인터페이스를 설계할 때는 여전히 세심한 주의**를 기울여야 한다.
    - 디폴트 메서드로 기존 인터페이스에 새로운 메서드를 추가하면 커다란 위험도 딸려온다.
    - 심각하게 잘못된 인터페이스라면 이를 포함한 api에 어떤 재앙을 몰고 올지 알 수 없다.
- 새로운 인터페이스를 만드는 경우라면 **매우 유용한 수단, 인터페이스를 더 쉽게 구현해 활용 가능**
- 새로운 인터페이스라면 **릴리스 전에 반드시 테스트**를 거쳐야 한다.
    - 다른 방식으로 최소한 세 가지는 구현해봐야 한다.
    - 각 인터페이스의 인스턴스를 다양한 작업에 활용하는 클라이언트도 여러 개 만들어봐야 한다.
    - 인터페이스를 릴리스한 후라도 결함을 수정하는게 가능한 경우도 있겠지만, 절대 그 가능성에 기대서는 안 된다.
- 인터페이스 변경 시 주의 사항
    - 인터페이스로 부터 메서드를 제거, 기존 메서드의 시그니터를 수정하는 용도
     → 이런 용도로 사용시 클라이언트 무너진다.