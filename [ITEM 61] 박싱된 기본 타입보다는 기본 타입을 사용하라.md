# Item 61 - 박싱된 기본 타입보다는 기본 타입을 사용하라

# Java의 데이터 타입

자바의 데이터 타입은 크게 두 가지가 존재합니다.

- 기본 타입 → `int` `float` `double`
- 참조 타입 → `String` `List`

그리고 또 하나의 참조 타입이 존재하는데 바로 박싱된 기본타입입니다.

## 박싱된 기본 타입

각각의 기본 타입에 대응하는 촘조 타입으로 `int` ⇒ `Integer` 등 으로 표현됩니다.

오토박싱과 오토언박싱으로 두 타입을 크게 구분하지 않고 사용가능하지만 이 차이에 대해 주의를 두어야 합니다.

# 기본 타입 VS 박싱된 기본 타입

기본 타입과 박싱된 기본 타입의 차이점은 크게 세 가지가 있습니다.

- 기본 타입은 값만 존재하지만 박싱된 기본 타입은 값 + 식별성(indentity) 속성 존재합니다.

    → 박싱된 기본 타입의 두 인스턴스는 값이 같아도 서로 다르다고 식별이 가능합니다.

- 기본 타입의 값은 언제나 유효하지만 박싱된 기본 타입은 유효하지 않은 값을 가질 수 있습니다.
- 기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용면에서 더 효율적입니다.
    - 박싱과 언박싱이 반복해서 일어나게 되면 성능이 느려집니다.

이러한 차이점로 만약 기본타입과 박싱된 기본타입을 구분하지 않고 사용한다면 문제가 발생할 수 있습니다.

🤔 그럼 만약 차이점을 생각하지 않고 사용했을 시에는 어떤 문제가 발생할까요?

## 차이점으로 인한 문제 발생 예시 1

```java
Comparator<Integer> naturalOrder = (i, j) -> (i < j) ? -1 : (i == j ? 0 : 1);
```

예제에서 문제점을 발견하셨나요? 실제로 테스트해봐도 잘 통과하지만 심각한 결함이 있습니다.!!

바로, `i` 와 `j` 를 `==` 연산자를 사용해 비교연산을 진행하는 부분 입니다.

→ 박싱된 기본 타입에 `==` 연산자를 사용하면 오류가 발생합니다.

```java
Comparator<Integer> naturalOrder = (iBoxed, jBoxed) -> {
    int i = iBoxed, j = jBoxed; // Auto-unboxing
    return i < j ? -1 : (i == j ? 0 : 1);
};
naturalOrder.compare(new Integer(42), new Integer(42));
```

이런 식으로 `compare`를 이용해서 비교를 해주어야 합니다.

## 차이점으로 인한 문제 발생 예시 2

```java
static Integer i;

public static void main(String[] args) {
    if (i == 42)
        System.out.println("Unbelievable");
}
```

이번 예시는 `NullPointerException`을 던집니다. 

바로, 문제는 `i` 가 `int` 가 아닌 `Interger` 타입으로 `i`의 초기값이 `null` 이라는 점에 입니다.

→ 기본 타입과 박싱된 기본타입을 혼용한 연산에서는 박싱된 기본 타입의 박싱이 자동으로 풀립니다.

즉, `42`가 기본타입이므로 `i`가 자동으로 언박싱 된것이죠.

# 그럼 박싱된 기본 타입은 어느곳에 사용해야 할까?

적절히 쓰이는 경우가 몇 가지 존재합니다.

- 컬렉션의 원소, 키, 값으로 사용합니다.

    → 컬렉션은 기본 타입을 담을 수 없으므로 어쩔 수 없이 박싱된 기본 타입을 써야 합니다.

    → 매개변수화 타입, 매개변수화 메서드의 타입 매개변수

    → 자바 언어는 타입 매개변수로 기본 타입 지원 X

- 리플렉션을 통해 메서드를 호출할 때 박싱된 기본타입 사용해야 합니다.

# 정리

- 기본 타입 VS 박싱된 기본 타입 ⇒ 가능하면 기본 타입 사용
- 오토박싱이 박싱된 기본 타입을 사용할 때의 번거로움 줄여주지만, 위험까지는 없애주지 못홥니다.