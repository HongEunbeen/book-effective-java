# Item 41 - 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라

# 마커 인터페이스(marker interface)

- 아무 메서드도 담고 있지 않음
- 자신을 구현하는 클래스가 특정 속성을 가짐을 표시해주는 인터페이스
- `Serializable` 인터페이스
    - `Serializable`은 자신을 구현한 클래스의 인스턴스는 `ObjectOutputStream`을  통해 직렬화 가능 알려줌
- 마커 인터페이스 VS 마커 애너테이션?

# 마커 인터페이스 사용 이점

마커 애너테이션이 등장하면서 마커 인터페이스는 구식이 되었다는 이야기 존재 → 사실 아님!!

## 1. 마커 인터페이스는 클래스의 인스턴스 구분 타입 사용

마커 인터 페이스는 이를 구현한 클래스의 인스턴스들을 구분하는 타입으로 사용 가능 

(마커 애너테이션은 그러지 않다!!)

마커 인터페이스는 타입이기 때문에 마커 애너테이션을 사용했다면 런타임에야 발견할 오류를 컴파일 타임에 확인 가능

### 마커 애너테이션의 잘못된 예시

자바의 직렬화는 `Serializable` 마커 인터페이스를 보고 그 대상이 직렬화 타입 확인

```java
public final void writeObject(Object obj) throws IOException
//당연히 인수로 받는 객체(obj)가 Serializable을 구현했을 거라고 가정
```

→ `Serializable`이 아닌 `Object` 객체 인수로 받을 수 있게 설계

→ 직렬화를 할 수 없는 객체를 넘겨도 런타임에 문제 확인 가능

마커 인터페이스를 사용하는 주요 이유가 컴파일 타임에 오류 검출 → 이점 살리지 못함

## 2. 마커 인터페이스는 적용 대상을 더 정밀하게 지정 가능

마커 인터페이스는 적용 대상을 더 정밀하게 지정할 수 있다

### 마커 에너테이션의 잘못된 예시

적용 대상(`@Target`)을 `ElementType.TYPE`으로 선언한 애너테이션은 모든 타입에 달 수 있음

→ 부착할 수 있는 타입 세밀하게 제한 불가

### 마커 인터페이스의 예시

특정 인터페이스를 구현한 클래스에만 적용하고 싶은 마커 존재 시 마커 인터페이스로 정의

→ 마킹하고 싶은 클래스에서 인터페이스 확장 가능

→ `Set` 인터페이스도 일종의 마커 인터페이스로 볼 수 있음

( `Set`은 `Collection`의 하위 타입에만 적용할 수 있고 `Collection`의 메서드 외에 새로 추가한 것 없기 때문)

## 마커 인터페이스 용도 정리

- 객체의 특정 부분을 불변식으로 규정 용도로 사용
- 그 타입의 인스턴스는 다른 클래스의 특정 메서드가 처리할 수 있다는 사실 명시 용도로 사용

# 마커 애너테이션 사용 이점

## 1. 거대한 애너테이션 시스템의 지원을 받는다

애너테이션을 적극 활용하는 플레임워크에서는 마커 애너테이션을 쓰는 쪽이 일관성을 지키는데 유리

# 마커 애너테이션 VS 마커 인터페이스

애너테이션 사용

- 클래스와 인터페이스 외의 프로그램 요소(모듈, 패키지, 필드, 지역변수 등)에 마킹시

    → 클래스와 인터페이스만이 인터페이스를 구현 or 확장 가능!

- 애너테이션을 확발히 활용하는 프레임워크에서 사용

인터페이스 사용

- 마커를 클래스나 인터페이스에 적용 시 "이 마킹이 된 객체를 매개변수로 받는 메서드를 작성할 일이 있을까?"라고 자문 후 그렇다 이면 마커 인터페이스 사용

    → 마커 인터페이스를 해당 메서드의 매개변수 타입으로 사용해 컴파일 타임에 오류 잡기 가능

# 정리

- 마커 인터페이스와 마커 애너테이션 각자의 쓰임 존재
- 새로 추가하는 메서드 없이 단지 타입 정의 목적 → 마커 인터페이스
- 클래스나 인터페이스외 프로그램 요소 마킹 or 애너테이션 적극 활용 프레임워크 → 마커 애너테이션