# Item 26 - 로 사용하지 말아라

# 제네릭 클래스, 제네릭 인터페이스란?

- 클래스와 인터페이스 선언에 **타입 매개변수**가 쓰이는 것
- 제네릭 클래스와 제네릭 인터페이스를 통틀어 **제네릭 타입**이라 칭함
- 각각의 제네릭 타입은 일련의 **매개변수화 타입(parameerized type)**을 정의
    - `List<E>` 인터페이스는 원소의 타입을 나타내는 타입 매개변수 `E`를 받는다.
    - `List<String>`을 원소의 타입이 `String`인 리스트를 뜻하는 매개변수화 타입

# 로 타입(raw type)

- 제네릭 타입을 하나 정의하면 그에 딸린 *로 타입*도 함께 정의 된다.
- ***로 타입***
    - 제네릭 타입에서 **타입 매개변수를 전혀 사용하지 않을 때**를 말한다.
    - `List<E>`의 로 타입 →  `List`
- 로타입은 타입선언에서 **제네릭 타입 정보가 전부 지워진 것처럼 동작** 
→ 제네릭이 도래하기 **전 코드와 호환**되도록 하기 위한 궁여지책(궁박한 나머지 생각다 못하여 짜낸 꾀.)

### 제네릭 지원 전 컬렉션 선언 방법

 - 동작을 하지만 좋은 예는 아니다.

```java
public class Main {
   public static void main(String args[]){
       //제네릭 지원 전 컬렉션 선언 방법(Java9 동작 가능)
       //Stamp 인스턴스만 취급한다.
       private final Collection stamps = ...;
 
       //실수로 동전을 넣는다.
       stamps.add(new Coin(...));
 
       //컬렉션에서 이 동전을 다시 꺼내기 전에는 오류를 알아채지 못한다.
       for(Integer i = stamps.iterator(); i.hasNext();){
           Stamp stamp = (Stamp) i.next();
           stamp.cancle();
       }
 
   }
}
```

- 이 코드 사용시 실수로 도장 대신 동전을 넣어도 **아무 오류 없이 컴파일 되고 실행**된다.
(경고 메시지는 보여줄 수 있다.)
- 오류는 가능한 한 발생 즉시, **이상적으로는 컴파일할 때 발견하는 것이 좋다.**
- 제네릭을 활용하면 주석의 정보 “Stamp 인스턴스만 취급한다”는 **문장이 주석이 아닌 타입 선언 자체에 녹아든다.**

```java
//제네릭 사용 시
private final Collection<Stamp> stamps = ...;
```

- 이렇게 선언하면 컴파일러는 stamps에는 **Stamp의 인스턴스만 넣어야 함을 컴파일러가 인지**하게 된다.

컴파일러는 컬렉션에서 **원소를 꺼내는 모든 곳에 보이지 않는 형변환을 추가**하여 **절대 실패하지 않음을 보장**한다.

> **로 타입을 쓰는걸 언어 차원에서 막아 놓지는 않았지만 절대로 써서는 안 된다.**

# Type  Erasure(타입 이레이저)

- 로 타입을 쓰면 제네릭의 장점 안전성과 표현력을 잃게 되지만 **지원하는 이유는 마이그레이션 호환성** 때문
    - 로 타입을 사용하는 메서드에 매개변수화 타입의 인스턴스를 넘겨도 작동 해야 했던 것
- 로 타입을 지원하는 대신 **제네릭에서 타입 이레이저** 지원
    - 원소 타입을 **컴파일 타임에만 검사**하고 **런타임에는 해당 타입 정보를 알 수 없는 것**
    - **컴파일 타임에만 타입에 대한 제약 조건을 적용**하고, **런타임에는 타입에 대한 정보를 소거**하는 프로세스
    - 컴파일 후 바이트코드(.class)에서는 제네릭 확인 불가
        - 자리 제한이 있는 타입으로 변경
        - 타입 파라미터 제한 타입 지정을 하지 않으면 `Object`로 변경

# 임의 객체를 허용하는 매개변수화 타입

- `List`같은 로 타입은 사용해서는 안되나, `List<Object>` 처럼 임의 객체를 허용하는 매개변수화 타입은 괜찮다
    - `List`는 제네릭 타입에서 완전히 발을 뺀것
    - `List<Object>`는 모든 타입을 허용한다는 의사를 컴파일러에 명확히 전달
- 제네릭의 **하위 타입 규칙 주의**
    - `List<String>`은 로 타입인 `List`의 하위 타입 → 타입 안전성 잃게 된다.
    - `List<String>`은 `List<Object>`의 하위 타입 X
        - `Obeject`는 모든 자바 클래스의 부모타입이 맞지만 `Object` 객체를 가지는 컬렉션이 다른 컬레션의 부모 타입 X

# 제네릭 사용 시 로 타입 사용

```java

 private final Collection<Stamp> stamps = ...;
     List<String> strings = new ArrayList<>();
     unsafeAdd(strings, Integer.valueOf(42));
     String s = strings.get(0);//컴파일러가 자동으로 형변환 코드를 넣어준다.

 }
 private static void unsafeAdd(List list, Object o ){//로 타입 List 사용
     list.ad
```

컴파일은 되지만 로 타입인 `List`를 사용하여 경고가 발생한다.

```java
//모르는 타입의 원소도 받는 로타입을 사용했다.
   static int numElementsInComoon(Set s1, Set s2){
       int result = 0;
       for(Object o1 : s1){
           if(s2.contains(o1)){
               result ++;
           }
           return result;
       }
   }
```

- 이렇게 사면 로 타입을 사용해 안전하지 않다.
- **비한정적 와일드 카드 타입(unbounded wildcard type)**을 대신 사용

# 비한정적 와일드 카드 타입(unbounded wildcard type)

- 제네릭 타입을 쓰고 싶지만 실제 타입 매개변수가 무엇인지 신경쓰고 싶지 않을 때 사용
    - 제네릭 타입인 `Set<E>`의 비한정적 와일드카드 타입은 `Set<?>`
    - 어떤 타입이라도 담을 수 있는 **가장 범용적인 매개변수화 Set 타입**

비한정적 와일드 카드 타입 `Set<?>` **vs** 로 타입 `Set`

- 와일드카드 타입 안전
    - Collection<?>에는 null 외에는 어떤 원소도 넣을 수 없다.
    - 다른 원소를 넣으려 하면 컴파일할 때 다음의 오류 메시지 (컴파일러는 제 역할을 한다.)
    - 컬렉션의 **타입 불변식을 훼손하지 못하게 막음**
- 로 타입 안전 x
    - 아무 원소나 넣을 수 있으니 **타입 불변식을 훼손 가능**

# 그럼에도 불구하고 로 타입 존재하는 이유

- `class` **리터럴에는 로 타입**
    - 자바 명세는 `class` 리터럴에 매개변수화 타입을 사용하지 못하게 했다.
        - 배열과 기본 타입은 허용)
        - `List.class`, `String[].class`, `int.class`는 허용
        - `List<String>.class`, `List<?>.class` 허용 x
- `instanceof` **연산자와 관련**
    - 런타임에는 제네릭 타입 정보가 지워지므로 `instanceof` 연산자는 **비한정적 와일드카드 타입 이외의 매개변수화 타입에는 적용 불가**
        - 타입을 알 수 없기 때문에
    - 로 타입이든 비한정적 와일드카드 타입이든 `instanceof`는 완전히 똑같이 동작
        - 코드 깔끔하게 로 타입 사용 추천

# 정리

- 로 타입 사용하면 **런타임에 예외**가 일어날 수 있으니 사용하면 안 된다.
- 로 타입은 **제네릭이 도입되기 이전 코드와의 호환성**을 위해 제공될 뿐이다.
- 매개변수화 타입
    - `Set<Object>` : 는어떤 타입의 객체도 저장할 수 있는
- 와일드카드 타입
    - `Set<?>` : 모종의 타입 객테만 저장할 수 있다.
- 로 타입
    - `Set`  : 제네릭 타입 시스템에 속하지 않는다.
- Set<Object> , Set<?>은 안전하지만, 로 타입인 Set은 안전하지 않다.