# Item 67 - 최적화는 신중히 하라

> 맹목적인 어리석음을 포함해 그 어떤 핑계보다 효율성이라는 이름 아래 행해진 컴퓨팅 죄악이 더 많다(심지어 효율을 높이지도 못하면서)
- 윌리엄 울프

> 전체의 97% 정도인 자그마한 효율성은 모두 잊자. 섣부른 최적화가 만악의 근원이다.
- 도널드 크누스

> 최적화를 할 때는 다음 두 규칙을 따르라.
첫 번째, 하지 마라
두 번째, 전문가 한정 아직 하지 마라. 다시 말해, 완전히 명백하고 최적화되지 않는 해법을 찾을 때까지는 하지 마라
- M. A. 잭슨

위의 격언 세 개는 최적화는 좋은 결과보다는 해로운 결과로 이어지기 쉽고, 섣불리 진행하지 말라고 합니다.

성능 때문에 견고한 구조를 희생하지 말고 빠른 프로그램보다는 좋은 프로그램을 작성해야 합니다.

좋은 프로그램은 정보 은직 원칙을 따르므로 개별 구성요소의 내부를 독립적으로 설계할 수 있습니다.

 

# 설계 단계의 성능

구현상의 문제는 나중에 최적화 가능하지만 아키텍처의 결함이 성능을 제한하는 상황이라면 시스템 전체를 수정해야 하기에 설계 단께에서 성능을 방드시 염두에 두어야 합니다.

### 성능을 제한하는 설계를 피해야 합니다.

완성 후 변경하기 어려운 설계 요소는 컴포넌트, 외부 시스템과의 소통 방식 등 입니다. 

API, 네트워크 프로토콜, 영구 저장용 데이터 포맷 증 완성 후 변경하기 어렵거나 불가능 할 수 있기에 성능을 심각하게 제한할 수 있습니다.

### API를 설계할 때 성능에 주는 영향을 고려합니다.

pulbic 타입을 가변으로 만들면 내부 데이터를 변경할 수 있어 불필요한 방어적 복사를 수없이 유발합니다. 

컴포지션으로 해결할 수 있는 문제을 상속 방식으로 설계한 public 클래스는 상위 클래스에 영원히 종속되며 성능 제약 물려받을 가능성 존재합니다.

API 설계가 성능에 주는 영향은 현실적인 문제인데요 다행히 잘 설계된 API는 성능도 좋은 게 보통입니다. 

성능을 위해 API를 왜곡하는 건 매우 안 좋은 생각입니다.

### 각각의 최적화 시도 전후로 성능을 측정하라

느릴 거라고 짐작한 부분이 성능에 별다른 영향을 주지 않는다면 최적화 시도는 시간만 허비한 꼴이 될 수 있습니다.

프로파일링 도구는 최적화 노력을 어디에 집중해야 할지 찾는데 도움을 줍니다. 이런 도구는 개별 메서드의 소비 시간과 호출 횟수 같은 런타임 정보를 제공해 집중할 곳은 물론 알고리즘을 변경해야 한다는 사실을 알려주기도 합니다.

마이크로 벤치마킹 프레임워크는 자바 코드의 상세한 성능을 알기 쉽게 보여줍니다.

# 최적화 성능 측정

성능 모델이 덜 성교한 Java에서는 최적화 시도 전후의 성능 측정의 중요성이 큽니다.

자바의 성능 모델은 정교하지 않을뿐더러 구현 시스템, 릴리스, 프로세서마다 차이가 있기에 최적화의 효과를 각각에서 측정해야 합니다.

# 정리

빠른 프로그램을 작성하려 안달하지 말아야 합니다.

하지만, 시스템을 설계할 때, API, 네트워크 프로토콜, 영구 저장용 데이터 포맷 설계 시 성능을 염두에 두어야 합니다.

시스템 구현 완료 후 성능 측정시 빠르면 끝입니다. 항상 모든 변경 후에는 성능을 측정해야 합니다.