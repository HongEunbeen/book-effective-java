# Item 62 - 다른 타입이 적절하다면 문자열 사용을 피하라

# String 타입을 사용하면 안되는 이유

문자열은 텍스트를 표현하도록 설계되었습니다. 하지만 문자열을 사용하지 말아야 할 사례도 존재합니다.

**문자열은 다른 값 타입을 대신하기에 적합하지 않습니다.**

입력으로부터 데이터를 받을 때 주로 문자열을 사용하지만 데이터가 수치형이라면 적당한 수치 타입으로 변화하고 적절한 열거 타입, `boolean`으로 변환해야 합니다.

기본 타입이든 참조 타입이든 적절한 값 타입이 있다면 그것을 사용하고, 없다면 새로 하나 작성해야 합니다.

**문자열은 열거 타입을 대신하기에 적합하지 않습니다.**

상수를 열거할 때는 문자열보다는 열거 타입이 월등히 낫습니다.

**문자열은 혼합 타입을 대신하기에 적합하지 않습니다.**

여러 요소가 혼합된 데이터를 하나의 문자열로 표현하는 것은 대체로 좋지 않은 생각입니다.

```java
String compoundKey = className + "#" + i.next();
```

위의 예제를 보면 단점이 존재합니다.

- 두 요소를 구분해주는 문자 `#` 이 `className` 또는 `i.next()` 에 존재 시 혼란을 유발할 수 있습니다.
- 각 요소를 개별로 접근하려면 문자열로 파싱해야 해 느리고, 오류 가능성이 커집니다.
- 적절한 `equals` `toString` `compareTo` 메서드 제공이 불가하며 `String` 제공 기능에만 의존해야 합니다.

이렇게 단점이 많이 존재하며 혼합된 데이터를 사용할 때에는 전용 클래스를 새로 만드는 편이 좋습니다. 보통 이런 클래스를 private 정적 멤버 클래스로 선언합니다.

**문자열은 권한을 표현하기에 적합하지 않습니다.**

권한을 문자열로 표현하는 경우가 종종 존재합니다. 

```java
public class ThreadLocal {
    private ThreadLocal() {} // 객체 생성 불가
    public static void set(String key, Object value);
    public static Object get(String key);
}
```

위의 예제에서는 스레드 구분용 key를 문자열(String)으로 표현을 했습니다. 

즉, 클라이언트가 제공한 문자열 키로 스레드별 지역변수를 식별한 것입니다.

이렇게 표현을 했을 때 발생하는 문제점은 스레드 구분용 문자열 키가 전역 이름 공간에 공유되어 의도치 않게 같은  문자열을 클라이언트가 사용하게 된다면 같은 변수를 공유하는 문제가 발생합니다.

```java
public class ThreadLocal { 
	private ThreadLocal() {} 
	public static class Key { 
		 Key() {} 
	} // 위조 불가능한 고유 키를 생성한다.
	public static Key getKey() { return new Key(); } 
	public static void set(Key key, Object value); 
	public static Object get(Key key); 
}
```

이런 식으로 코드를 변경하게 되면 문자열 대신 위조할 수 없는 키를 사용했습니다. 이 키를 권한 이라고 합니다.

# 정리

더 적합한 데이터 타입이 존재하고나 새로 작성할 수 있는 경우 문자열 대신 사용해야 합니다.

예로는 기본 타입, 열거 타입, 혼합 타입 등이 존재합니다.